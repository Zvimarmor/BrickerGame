zvi.marmor,adi_zuarets
206949539,208708925

########question 1#######
בשביל לאפשר העלמת לבנים במשחק השתמשנו בתבנית העיצובStrategy.
יצרנו ממשק CollisionStrategy  עם מתודת - onCollisio המוגדרת על כל התנהגות מיוחדת שנרצה לממש.
מחלקתBrick  מחזיקה מופע שלCollisionStrategy והוא מופעל כאשר מתנגש בה משהו.
כך, הלבנה אינה אחראית על פעולת ההתנגשות אלא רק מפעילה את האסטרטגיה שניתנה לה.
יתרונות השיטה -
- מפשט את מחלקת BrickerGameManager בכך שהוא מעביר את האחריות להסרת הלבנה למחלקת האסטרטגיה הרלוונטית.
-	מאפשר הוספת אסטרטגיות חדשות מבלי לשנות את ניהול המשחק המרכזי-
מתאים לעקרון הפתיחות/סגירות – ניתן להרחיב מבלי לשנות את הקיים.
חסרונות השיטה - 
- קבצי האסטרטגיות נחשפים למימוש פנימי של המשחק - דבר שמפחית את ההפרדה
המלאה בין האחריות של האובייקטים.


########question 2#######

לצורך הצגת מספר החיים של השחקן,
יצרנו את המחלקה
HeartsPanel מטרתה היא לנהל ולהציג את מצב החיים של השחקן בצורה גרפית (לבבות) ובצורה נומרית (מספר).
המחלקה בעצם מייצגת פאנל שמכיל בתוכו את אובייקטים אלו - הלבבות והמספר להצגה.

הסבר על ההצגה ופונקציונליות המחלקה - 
•	לבבות (ייצוג גרפי): באמצעות מערך רשימה-heartObjects, אנו שומרים האובייקטים הגרפיים של הלבבות.
כל לב הוא אובייקט מסוגGameObject  עם תמונה של לב. הלבבות מוצבים בצורה אופקית בהתאם למספר החיים הנוכחי.
•	מספר (ייצוג נומרי): באמצעות אובייקט מסוג-TextRenderable ,
 אובייקט זה מציג את מספר החיים של השחקן, ומתעדכן בכל הוספה או הסרה של לב.
  צבע הטקסט משתנה בהתאם למספר החיים.
•	הוספה והסרה של חיים: כאשר יש צורך להוסיף או להסיר לב,
 מתבצעת קריאה לפונקציות addHeart()  אוremoveHeart()  בהתאמה.
 שתי הפונקציות משתמשות בפונקציהcreateHearts()
  שמסירה את כל הלבבות הקודמים ויוצרת מחדש את כל הלבבות במספר המתאים.
•	 כל העצמים (הלבבות והטקסט) נוספים לשכבת ה – UI,
 כדי שיופיעו תמיד על המסך ללא קשר למיקום של אובייקטים אחרים.


########question 3#######
3.	במשחק מימשנו מספר התנהגויות מיוחדות עבור הלבנים,
 כל אחת מהן ממומשת במחלקה נפרדת המממשת את הממשק CollisionStrategy.
 כל אסטרטגיה מקבלת את הפרמטרים הדרושים לה ומממשת את שיטת-onCollision הנקראת כאשר יש פגיעה בלבנה.
נפרט על המחלקות השונות שהוספנו –

ExtraBallsStrategy
במימוש זה, לאחר התנגשות הלבנה נמחקת ונוצרים שני כדורים קטנים (mini balls) חדשים במקום.
 כל כדור מקבל כיוון מהירות שונה, אקראי כלפי מעלה, ונוסף למשחק.
לצורך כך יצרנו מחלקה חדשה בשם Puck שמרחיבה את GameObject.
 המחלקה אחראית על המאפיינים של הכדורים הנוספים (כמו תמונה, גודל, התנהגות בעת התנגשות ויציאה מהמסך).
 כל כדור כזה מתנהג באופן עצמאי, כולל התנגשויות עם לבנים.

PaddleDuplicatorStrategy
כאן, עם פגיעת הכדור בלבנה, נוצרת דיסקית נוספת באמצע המסך – אך רק במידה שאין אחת כזו כבר בלוח.
הדיסקית הנוספת היא מופע של מחלקה פנימית שיצרנו
 בשם HitCountingPaddle המחלקה הפנימית מרחיבה את מחלקת Paddle.
 מחלקה זו עוקבת אחרי מספר הפגיעות של הכדורים (כולל כדורים נוספים),
  ולאחר 4 פגיעות, היא מסירה את עצמה מהמשחק.

LifeRestorationStrategy
כאשר לבנה בעלת אסטרטגיה זו נפגעת, היא נעלמת מהמשחק ונוצר במיקומה אובייקט חדש מסוג FallingHeart .
 זהו לב הנופל אנכית כלפי מטה במהירות קבועה, עד שהוא פוגש בדיסקית הראשית או יוצא מגבולות המסך.
בשביל מימוש ההתנהגות יצרנו מחלקה חדשה בשםFallingHeart  שמרחיבה את GameObject. המחלקה נבנה כך ש:
•	הלב מוגדר כך שיוכל להתנגש רק עם הדיסקית הראשית (MainPaddle) על ידי דריסת shouldCollideWith.
•	כאשר מתבצעת ההתנגשות, הלב נבדק מול מספר החיים הנוכחי.
 אם הוא קטן מהמקסימום, מתבצע עדכון במספר החיים על ידי קריאה ל-addHeart  של מחלקת הפאנל.
•	הלב תמיד מוסר מהמשחק לאחר ההתנגשות או אם עבר את גבול המסך.
•	תנועת הלב כלפי מטה מתבצעת במסגרת הדריסה של update.

TurboModeStrategy
כאשר לבנה בעלת אסטרטגיה זו נפגעת על ידי הכדור הראשי-MainBall . הכדור עובר למצב טורבו. במצב זה:
•	מהירות הכדור מוכפלת על ידי כפל הווקטור שלו פי 1.4.
•	הדימוי (Renderable) של הכדור משתנה לתמונה של כדור אדום.
•	באמצעות setComponent אנחנוו מוסיפים לכדור קומפוננטה שמתבצעת
בכל פריים ובודקת את מספר ההתנגשויות של הכדור מאז הופעל מצב הטורבו.
•	לאחר 6 התנגשויות, הקומפוננטה מסירה את עצמה, מחזירה את המהירות המקורית ומחזירה את הכדור לתמונה הרגילה.
המעקב אחר מספר הפגיעות נעשה באמצעות getCollisionCount() –  מונה פנימי של האובייקט Ball.
 כך, השפעת מצב הטורבו נמשכת בדיוק 6 התנגשויות ומסתיימת באופן עצמאי, בלי צורך במשתנים חיצוניים.

כל האסטרטגיות הללו מופעלות בעזרת תבנית עיצוב מפעל - BrickFactory

יצרנו מחלקה בשם BrickFactory שתפקידה לבחור לכל לבנה אסטרטגיה אקראית מתוך מגוון האפשרויות.
 היא משתמשת במחולל מספרים אקראיים כדי להחליט איזו התנהגות לקבל,
 וכך מאפשרת רנדומליות במשחק. בנוסף, השימוש במחלקת מפעל מאפשר להרחיב את המשחק בקלות:
 ניתן להוסיף אסטרטגיות חדשות בעתיד מבלי לשנות את שאר חלקי הקוד. כל שינוי מתבצע במקום אחד – במפעל.


########question 4#######

בשביל ליצור את ההתנהגות הכפולה השתמשנו בתבנית עיצוב
 שמקבלת בתוכה אובייקטים של אסטרטגיות (שתיים או שלוש בהתאם לצורך),
 המחלקה קוראת לאסטרטגיות אלו בעת התנגשות וכך בעצם הן מצבעות את האסטרטגיה שלהן.
בשביל להגביל את ההתנהגויות רק לשלוש, ביצענו הגרלה באקראי (שימוש בrandom) לבחירת שתי אסטרטגיות-
- אסטרטגיה ראשונה נבחרה מתוך ארבעת האפשרויות (כלומר בלי הבחירה הכפולה),
 האסטרגיה נקבעת דרך פונקצית – getStrategy עם המספר שהוגרל.
- לאסטרטגיה השנייה הוגרל מספר בין 0-4, אשר 4 מסמל את האופציה של הבחירה הכפולה. אם מספר 4 נבחר-
 אנחנו מבצעים הגרלה מחדש גם לאסטרטגיה השנייה וגם לשלישית
  (בעצם מפעילים את האסטרטגיה השלישית שהגדרנו בהתחלה כ-null).
 ההגרלה היא רק לארבעת האסטרטגיות הנוספות (מבלי הבחירה הכפולה)
  דרך קריאה ל- getStrategy כפי שעשינו באסטרטגיה הראשונה.
בדרך זו אנו בעצם מאפשרים רק קריאה אחת לאסטרטגית הדאבל מה שמגביל את מקסימום ההתנהגויות להיות 3.

########Add class#######
הוספת מחלקת Constants לתרגיל -
מחלקת Constants  משמשת כמרכז ניהול קבועים (מנהלת) של המשחק כולו.
 ריכזנו בה את כל המשתנים הקבועים שנוגעים לעיצוב המשחק, מהירויות,
 גדלים ומספרים קבועים – כמו גודל החלון, מהירות הכדור, מספר חיים התחלתי, מיקום הפאנל, גודל לבנה, וכו'.
הרעיון המרכזי מאחורי השימוש במחלקה זו הוא הפרדת האחריות:
במקום להעביר משתנים קבועים לכל אחת מהמחלקות
 (מה שהיה מסרבל את הקוד ומוביל לעבודה עם יותר מדי ארגומנטים לבנאים),
  כל מחלקה פשוט שואבת את הערכים הקבועים מתוך המחלקה.
כך למשל, אם נרצה לעשות שינויים בפונקציונליות המשחק –
 כמו לשנות את מהירות הכדור או את מספר החיים המקסימלי,
  נוכל לעשות זאת במקום אחד בלבד – בלי לגעת במחלקות האחרות.
מחלקה זו מאפשרת תחזוקה נוחה יותר וקוד ברור יותר.



